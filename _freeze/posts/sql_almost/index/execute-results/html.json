{
  "hash": "fcba8216bdf08a5c86c1efc069ea95df",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"(Almost) All SQL You Need\"\nauthor: \"cstorm125\"\ndate: \"2025-06-29\"\ncategories: [sql, tutorial]\nimage: \"featured_image.jpg\"\nsidebar:\n  contents: auto\nformat:\n  html:\n    code-fold: true\njupyter: python3\ntoc: true\ntoc-location: left\n---\n\nSkill mastery is an endeavor of diminishing returns. You can get from zero to [good enough](http://act-r.psy.cmu.edu/wordpress/wp-content/uploads/2012/12/63ACS_JRA_PR.1982.pdf) (think first-time chess player to 500 online rating) within 100 hours of deliberate practice; however, it is exponentially more difficult to get from good enough to [mastered](https://www.researchgate.net/publication/224827585_The_Role_of_Deliberate_Practice_in_the_Acquisition_of_Expert_Performance) (think a 500-rated chess player trying to become a 2200-FIDE-rated Candidate Master), requiring over 100x more delibrate practice. SQL is the basic building blocks of data analysis and I posit that most peopleーproduct managers, marketers, salespeople, and other makeshift data analystsーsimply need to be good enough. \n\nThis tutorial aims to encapsulate almost all SQL techniques you need to glean actionable insights from your ([non-transactional](https://stackoverflow.com/questions/18884728/difference-between-transactional-and-non-transactional)) datasets. We will use the [Taobao User Behavior](https://www.kaggle.com/datasets/marwa80/userbehavior) dataset and [duckdb](https://duckdb.org/) to simulate a SQL interface. There will be idiosyncracies according to which flavors of SQL you are usingーPostgres, Presto, Redshift, BigQuery, and so onーbut you should be able to adapt the principles outlined here with a little help of modern coding assistants.\n\nI recommend that you first quickly skim through this post to have a rough idea of what SQL is all about, then move on to complete the [exercise](https://colab.research.google.com/github/cstorm125/cstorm125.github.io/blob/main/notebook/sql_almost_exercise.ipynb) for some hands-on shenanigans. While completing it, feel free to refer back to this post and read some sections more in details. The road to becoming a true SQL monkey starts with writing queries.\n\n![featured_image](featured_image.jpg)\n\n::: {#822dfe17 .cell execution_count=1}\n``` {.python .cell-code}\nimport duckdb\nimport pandas as pd\npd.set_option('display.max_rows', 6) \nimport numpy as np\nimport random\nfrom tqdm.auto import tqdm\nimport os\nimport timeit\n\n\ndf = pd.read_csv('../../data/sql_almost/UserBehavior.csv',\n      header=None)\ndf.columns = [\n  'user_id',\n  'item_id',\n  'category_id',\n  'behavior_type',\n  'timestamp']\n\n#sample 5M rows out of 100M to run in reasonable time\ndf = df.sample(n=5_000_000, random_state=112).reset_index(drop=True)\n\n# # save to parquet\n# con = duckdb.connect()\n# con.register('transaction_tbl', df)\n# output_dir = '../../data/sql_almost/transaction_tbl'\n# os.makedirs(output_dir, exist_ok=True)\n\n# con.execute(f\"\"\"\n# COPY transaction_tbl\n# TO '{output_dir}'\n# (FORMAT PARQUET, PARTITION_BY (category_id, behavior_type), OVERWRITE_OR_IGNORE);\n# \"\"\")\n```\n:::\n\n\n## 0. Intuition\n\nImagine you are at a library to look for a certain piece of information. The entire library is off limits to the general public. The only way you can access any information is by telling the librarian exactly what you want and let them fetch it for you. The entire library is your **database**. The librarian is your **query engine** and what you tell them is your **query**. In the library, there are a number of shelves (representing **tables**) that contain any number of books (representing **rows** in a table) to answer your query. Each book from the same shelf contains the same number of pages (representing **columns** or **fields** in a row), each page having a distinct piece of information. Following your instruction, the librarian may walk to different shelves, scour some books and pages, mix-and-match the information, then present the answer to you. Therefore, our task is to give an instruction such that the librarian can give us the most accurate answer using the shortest time and energy possible.\n\n## 1. Sanity Checks Keep You Sane\n\nWe are treating the [Taobao User Behavior](https://www.kaggle.com/datasets/marwa80/userbehavior) dataset as our table called `transaction_tbl`. It is a 5M-row subset based on parquet files partitioned by `category_id` and `behavior_type`.\n\n::: {#d3af1054 .cell execution_count=2}\n``` {.python .cell-code}\ncon = duckdb.connect()\n\n#short-hand function to execute query with duckdb easily\ndef execute_query(query): return con.execute(query).fetchdf()\n\nquery = f\"\"\"\nCREATE OR REPLACE TABLE transaction_tbl AS\nSELECT *\nFROM read_parquet('../../data/sql_almost/transaction_tbl/*/*/*.parquet', hive_partitioning=true);\n\"\"\"\n\n#load saved, partitioned table as transaction_tbl\nexecute_query(query)\n```\n:::\n\n\nThe table is a run-of-the-mill user behavior log consisting of \n\n* `user_id`: identifier of user\n* `item_id`: identifier of item\n* `timestamp`: unix timestamp of when action happened\n* `behavior_type`: what type of action it was\n* `category_id`: identifier of category the item belongs to\n\n\n### Example: `select *`\n\nThe first thing you do with a table you have not seen before is to select a few rows to look at. The texts in variable `query` is what you would type in your SQL interface.\n\n::: {#f682b6a3 .cell execution_count=3}\n``` {.python .cell-code code-fold=\"show\"}\nquery = f\"\"\"\nselect * from transaction_tbl limit 100;\n\"\"\"\n\nexecute_query(query)\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>user_id</th>\n      <th>item_id</th>\n      <th>timestamp</th>\n      <th>behavior_type</th>\n      <th>category_id</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>184439</td>\n      <td>688483</td>\n      <td>1512105722</td>\n      <td>buy</td>\n      <td>1000858</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>860167</td>\n      <td>3032030</td>\n      <td>1511876592</td>\n      <td>pv</td>\n      <td>1000858</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>29019</td>\n      <td>1174848</td>\n      <td>1511952716</td>\n      <td>pv</td>\n      <td>1000858</td>\n    </tr>\n    <tr>\n      <th>...</th>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n    </tr>\n    <tr>\n      <th>97</th>\n      <td>109393</td>\n      <td>336502</td>\n      <td>1512302682</td>\n      <td>pv</td>\n      <td>1003726</td>\n    </tr>\n    <tr>\n      <th>98</th>\n      <td>928768</td>\n      <td>2826670</td>\n      <td>1511780591</td>\n      <td>pv</td>\n      <td>1003726</td>\n    </tr>\n    <tr>\n      <th>99</th>\n      <td>719622</td>\n      <td>2297792</td>\n      <td>1511703912</td>\n      <td>pv</td>\n      <td>1003726</td>\n    </tr>\n  </tbody>\n</table>\n<p>100 rows × 5 columns</p>\n</div>\n```\n:::\n:::\n\n\n`select *` returns all columns from a table, and is almost always followed by `limit [NUMBER OF ROWS YOU WANT]` in order to not return the entire table but a random subset of it. This is less of a problem in the day and age where most query engines have a built-in safeguard to not display the entire table as a result, otherwise you can crash your system by asking for a terabyte-level output.\n\n### Example: `describe`\n\nAnother useful command is `describe`. It will tell you what the columns are, their data types, do they have null (missing) values and so on. Common data types are `int/bigint` for integers, `float` for approximate decimals, `varchar/string` for texts, `boolean` for true/false and `timestamp/date` for, well, timestamps and dates. However, they are always ever so slightly different depending on which SQL you are using so better confirm with the documentation such as [this one for Presto](https://prestodb.io/docs/current/language/types.html).\n\n::: {#80727b49 .cell execution_count=4}\n``` {.python .cell-code code-fold=\"show\"}\nquery = f\"\"\"\ndescribe transaction_tbl;\n\"\"\"\n\nexecute_query(query)\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>column_name</th>\n      <th>column_type</th>\n      <th>null</th>\n      <th>key</th>\n      <th>default</th>\n      <th>extra</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>user_id</td>\n      <td>BIGINT</td>\n      <td>YES</td>\n      <td>None</td>\n      <td>None</td>\n      <td>None</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>item_id</td>\n      <td>BIGINT</td>\n      <td>YES</td>\n      <td>None</td>\n      <td>None</td>\n      <td>None</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>timestamp</td>\n      <td>BIGINT</td>\n      <td>YES</td>\n      <td>None</td>\n      <td>None</td>\n      <td>None</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>behavior_type</td>\n      <td>VARCHAR</td>\n      <td>YES</td>\n      <td>None</td>\n      <td>None</td>\n      <td>None</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>category_id</td>\n      <td>BIGINT</td>\n      <td>YES</td>\n      <td>None</td>\n      <td>None</td>\n      <td>None</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n### Example: `count` and `count(distinct [COLUMN])`\n\nThe last check you always want to do is to `count` how many rows exist in the table:\n\n::: {#a5fee1b0 .cell execution_count=5}\n``` {.python .cell-code code-fold=\"show\"}\nquery = f\"\"\"\nselect count(*) from transaction_tbl;\n\"\"\"\n\nexecute_query(query)\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>count_star()</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>5000000</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nWe can also count how many unique values are in any column by adding `distinct` in front of the column name in `count`. You can also name your derived columns to know which ones mean what using `as`.\n\n::: {#ec32bc92 .cell execution_count=6}\n``` {.python .cell-code code-fold=\"show\"}\n# count how many unique users\nquery = f\"\"\"\nselect \n count(*) as nb_event\n ,count(distinct user_id) as nb_user\nfrom transaction_tbl;\n\"\"\"\n\nexecute_query(query)\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>nb_event</th>\n      <th>nb_user</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>5000000</td>\n      <td>888335</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n## 2. Assorted Platter of Selects\n\nNow that you know how to sanity-check a table, let us move on to selecting what you want. This is often done by filtering the result with conditions using the `where` clause. Here are some examples you want to familiarize yourself with.\n\n### Example: Who are the users that viewed item 2067266?\n\nLink multiple conditions with logical operators `and` / `or`.\n\n::: {#74187b93 .cell execution_count=7}\n``` {.python .cell-code code-fold=\"show\"}\nquery = f\"\"\"\nselect \n distinct user_id\nfrom transaction_tbl\nwhere behavior_type = 'pv'\n and item_id = 2067266;\n\"\"\"\n\nexecute_query(query)\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>user_id</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>377356</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>690994</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>485340</td>\n    </tr>\n    <tr>\n      <th>...</th>\n      <td>...</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>469061</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>457064</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>329947</td>\n    </tr>\n  </tbody>\n</table>\n<p>7 rows × 1 columns</p>\n</div>\n```\n:::\n:::\n\n\n### Example: Who are the users that viewed item 2067266, ranked by who viewed last to who viewed first?\n\nWe use `order by [COLUMN]` followed by `asc` for ascending order (default) and `desc` for descending order. \n\n::: {#44788f76 .cell execution_count=8}\n``` {.python .cell-code code-fold=\"show\"}\nquery = f\"\"\"\nselect \n user_id\n ,timestamp\nfrom transaction_tbl\nwhere behavior_type = 'pv'\n and item_id = 2067266\norder by timestamp desc;\n\"\"\"\n\nexecute_query(query)\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>user_id</th>\n      <th>timestamp</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>241453</td>\n      <td>1512288234</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>485340</td>\n      <td>1512160311</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>690994</td>\n      <td>1512127740</td>\n    </tr>\n    <tr>\n      <th>...</th>\n      <td>...</td>\n      <td>...</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>469061</td>\n      <td>1511865189</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>329947</td>\n      <td>1511850299</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>457064</td>\n      <td>1511601891</td>\n    </tr>\n  </tbody>\n</table>\n<p>7 rows × 2 columns</p>\n</div>\n```\n:::\n:::\n\n\n### Example: How many users did not buy?\n\n`<>` means not equal.\n\n::: {#0b9c9ae7 .cell execution_count=9}\n``` {.python .cell-code code-fold=\"show\"}\nquery = f\"\"\"\nselect \n count(distinct user_id) \nfrom transaction_tbl\nwhere behavior_type <> 'buy';\n\"\"\"\n\nexecute_query(query)\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>count(DISTINCT user_id)</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>882077</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n### Example: How many events happened before November 26, 2017 (timestamp 1511622000)?\n\n`>`, `<`, `>=`, `<=` also works with numeric columns.\n\n::: {#4dc7bf7d .cell execution_count=10}\n``` {.python .cell-code code-fold=\"show\"}\nquery = f\"\"\"\nselect \n count(*)\nfrom transaction_tbl\nwhere timestamp < 1511622000;\n\"\"\"\n\nexecute_query(query)\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>count_star()</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>489758</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n### Example: How many events happened between November 25, 2017 (timestamp 1511535600) and November 26, 2017 (timestamp 1511622000)?\n\nYou can use `between` to replace `>=` and `<=`.\n\n::: {#476bd504 .cell execution_count=11}\n``` {.python .cell-code code-fold=\"show\"}\nquery = f\"\"\"\nselect \n count(*)\nfrom transaction_tbl\nwhere timestamp between 1511535600 and 1511622000;\n\"\"\"\n\nexecute_query(query)\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>count_star()</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>487676</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n### Example: How many events are either purchase (`buy`) or add-to-cart (`cart`)?\n\nWe can use `in` in place of multiple `or`\n\n::: {#8aa3bbb4 .cell execution_count=12}\n``` {.python .cell-code code-fold=\"show\"}\nquery = f\"\"\"\nselect \n count(*)\nfrom transaction_tbl\nwhere behavior_type in ('buy', 'cart');\n\"\"\"\n\nexecute_query(query)\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>count_star()</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>376999</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nCheck to see if multiple `or` really gives the same result.\n\n::: {#f97c8b57 .cell execution_count=13}\n``` {.python .cell-code code-fold=\"show\"}\nquery = f\"\"\"\nselect \n count(*)\nfrom transaction_tbl\nwhere behavior_type = 'buy' or behavior_type = 'cart';\n\"\"\"\n\nexecute_query(query)\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>count_star()</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>376999</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n### Example: How many users interact (`pv`, `cart`, `fav`) with Taobao but never `buy`?\n\nWe can use `not` as a negation for `in`.\n\n::: {#c3bd2a06 .cell execution_count=14}\n``` {.python .cell-code code-fold=\"show\"}\nquery = f\"\"\"\nselect \n count(distinct user_id)\nfrom transaction_tbl\nwhere behavior_type not in ('buy');\n\"\"\"\n\nexecute_query(query)\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>count(DISTINCT user_id)</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>882077</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n### Example: How many `behavior_type` ends with a `v`?\n\nWe use `like` to match texts that are similar what we want. `%` is the wild card to say anything can come before/after it. In this simple example, we already know the answer is 2: `pv` and `fav`.\n\n::: {#e3240c52 .cell execution_count=15}\n``` {.python .cell-code code-fold=\"show\"}\nquery = f\"\"\"\nselect \n count(distinct behavior_type)\nfrom transaction_tbl\nwhere behavior_type like '%v';\n\"\"\"\n\nexecute_query(query)\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>count(DISTINCT behavior_type)</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>2</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n## 3. Partitions, Partitions, Partitions\n\nOnce you have mastered the basic select patterns, the next thing you must never forget when selecting from a table is to **ALWAYS SPECIFY THE PARTITIONS YOU NEED IN THE `WHERE` CLAUSE**. A modern SQL table is stored as multiple compressed files (most commonly `parquet`) in a nested subfolder structure as seen below. In this case, the partitions (subfolders) are columns `category_id` and `behavior_type`.\n\n> Fun Fact: Not only do you need to specify the partitions, you need to specify them with the **correct data types**. I once had a query than ran for 12 hours instead of 5 minutes, simply because I did not check if the partition was in datetime not string. Do not be me.\n\n::: {#26f986d2 .cell execution_count=16}\n``` {.python .cell-code}\ndef print_table_structure(table_path, first_category_id_dir):\n\n    #print root folder\n    print(table_path.split(os.sep)[-1])  \n\n    #get category_id partitions\n    category_ids = sorted([d for d in os.listdir(table_path) if os.path.isdir(os.path.join(table_path, d)) and d.startswith('category_id=')])\n\n    #print only the first category_id partition\n    category_id_path = os.path.join(table_path, first_category_id_dir)\n    print(f\"  └── {first_category_id_dir}\")\n\n    #get behavior_type partitions\n    behavior_types = sorted([d for d in os.listdir(category_id_path) if os.path.isdir(os.path.join(category_id_path, d)) and d.startswith('behavior_type=')])\n\n    #print all behavior_type partitions\n    for behavior_type_dir in behavior_types:\n      behavior_type_path = os.path.join(category_id_path, behavior_type_dir)\n      print(f\"    └── {behavior_type_dir}\")\n\n      #get all parquet files\n      files = sorted([f for f in os.listdir(behavior_type_path) if f.endswith('.parquet')])\n\n      #print all files under category_id, behavior_type partitions\n      for i, file in enumerate(files):\n          if i == len(files) - 1:\n              print(f\"        └── {file}\")\n          else:\n              print(f\"        ├── {file}\")\n\n    if len(category_ids) > 1:\n        print(f\"  {len(category_ids) - 1} more category_id folders...\")\n\nprint_table_structure('../../data/sql_almost/transaction_tbl','category_id=1462446')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntransaction_tbl\n  └── category_id=1462446\n    └── behavior_type=buy\n        ├── data_0.parquet\n        ├── data_1.parquet\n        ├── data_10.parquet\n        ├── data_2.parquet\n        ├── data_3.parquet\n        ├── data_4.parquet\n        ├── data_5.parquet\n        ├── data_6.parquet\n        ├── data_7.parquet\n        ├── data_8.parquet\n        └── data_9.parquet\n    └── behavior_type=cart\n        ├── data_0.parquet\n        ├── data_1.parquet\n        ├── data_10.parquet\n        ├── data_2.parquet\n        ├── data_3.parquet\n        ├── data_4.parquet\n        ├── data_5.parquet\n        ├── data_6.parquet\n        ├── data_7.parquet\n        ├── data_8.parquet\n        └── data_9.parquet\n    └── behavior_type=fav\n        ├── data_0.parquet\n        ├── data_1.parquet\n        ├── data_2.parquet\n        ├── data_3.parquet\n        ├── data_4.parquet\n        ├── data_5.parquet\n        ├── data_6.parquet\n        └── data_7.parquet\n    └── behavior_type=pv\n        ├── data_0.parquet\n        ├── data_1.parquet\n        ├── data_10.parquet\n        ├── data_2.parquet\n        ├── data_3.parquet\n        ├── data_4.parquet\n        ├── data_5.parquet\n        ├── data_6.parquet\n        ├── data_7.parquet\n        ├── data_8.parquet\n        └── data_9.parquet\n  7796 more category_id folders...\n```\n:::\n:::\n\n\nTo understand why specifying partitions is crucial, let us try our first query again and see how long it takes to run. We conduct 100 trials of 100 runs each to get mean and standard deviation of query time.\n\n### Example: Who are the users that viewed item 2067266? Run WITHOUT partition in `where` clause.\n\n::: {#59741120 .cell execution_count=17}\n``` {.python .cell-code code-fold=\"show\"}\nquery = \"\"\"\nselect distinct user_id from transaction_tbl\nwhere item_id = 2067266;\n\"\"\"\n\nts = timeit.repeat(\n  lambda: execute_query(query),\n  number=100,\n  repeat=100\n)\n\nprint(f'Query time WITHOUT partition: {np.mean(ts):.2f}±{np.std(ts):.2f} seconds')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nQuery time WITHOUT partition: 0.15±0.08 seconds\n```\n:::\n:::\n\n\n### Example: Who are the users that viewed item 2067266? Run WITH `category_id` partition in `where` clause.\n\n::: {#ab96d6b3 .cell execution_count=18}\n``` {.python .cell-code}\nquery = \"\"\"\nselect distinct user_id from transaction_tbl\nwhere item_id = 2067266\n and category_id = 4339722;\n\"\"\"\n\nts = timeit.repeat(\n  lambda: execute_query(query),\n  number=100,\n  repeat=100\n)\n\nprint(f'Query time WITH partition: {np.mean(ts):.2f}±{np.std(ts):.2f} seconds')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nQuery time WITH partition: 0.06±0.06 seconds\n```\n:::\n:::\n\n\nWhat sorcery is this? The query time is roughly halved! This is because when we include partitions in the `where` clause, we are telling the query engine to *only look at the specific parts of the data* not the entire table. In real life, not specifying which partitions you need as detailed as possible can spell the difference between waiting for two hours or a few seconds.\n\n## 4. Column-wise Manipulation\n\nBefore we move on, you might have noticed that our dataset is a little bland with only a timestamp and categorical columns (`timestamp`, `user_id`, `item_id`, `category_id`, `behavior_type`). In reality, such table as the one we are using often contains `price` of the item and `quantity` by which they were purchased. We can add that by manipulating existing columns.\n\n### Example: Add `price` column where price is `item_id` modulus 1000 + 50\n\nHere we add the `price` column we randomly generated to the result. You can manipulate any numeric columns with [arithmetic operators](https://www.geeksforgeeks.org/sql-arithmetic-operators/]).\n\n::: {#360fb992 .cell execution_count=19}\n``` {.python .cell-code code-fold=\"show\"}\nquery = f\"\"\"\nselect \n *\n ,item_id % 1000 + 50 as price\nfrom transaction_tbl;\n\"\"\"\n\nexecute_query(query)\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>user_id</th>\n      <th>item_id</th>\n      <th>timestamp</th>\n      <th>behavior_type</th>\n      <th>category_id</th>\n      <th>price</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>184439</td>\n      <td>688483</td>\n      <td>1512105722</td>\n      <td>buy</td>\n      <td>1000858</td>\n      <td>533</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>860167</td>\n      <td>3032030</td>\n      <td>1511876592</td>\n      <td>pv</td>\n      <td>1000858</td>\n      <td>80</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>29019</td>\n      <td>1174848</td>\n      <td>1511952716</td>\n      <td>pv</td>\n      <td>1000858</td>\n      <td>898</td>\n    </tr>\n    <tr>\n      <th>...</th>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n    </tr>\n    <tr>\n      <th>4999997</th>\n      <td>461462</td>\n      <td>1642299</td>\n      <td>1511677441</td>\n      <td>pv</td>\n      <td>999980</td>\n      <td>349</td>\n    </tr>\n    <tr>\n      <th>4999998</th>\n      <td>891831</td>\n      <td>2064564</td>\n      <td>1512255716</td>\n      <td>pv</td>\n      <td>999980</td>\n      <td>614</td>\n    </tr>\n    <tr>\n      <th>4999999</th>\n      <td>10430</td>\n      <td>2006178</td>\n      <td>1512012994</td>\n      <td>pv</td>\n      <td>999980</td>\n      <td>228</td>\n    </tr>\n  </tbody>\n</table>\n<p>5000000 rows × 6 columns</p>\n</div>\n```\n:::\n:::\n\n\n### Example: Add `quantity` column that is a random number between 1 and 10, only for `buy` events. For all other events, leave it as missing values (`null`).\n\nWhen you buy from a store, you need to specify a quantity of the items; however, for other events (when you view, favorite or add-to-cart), you do not. We must give the query engine an if-else logic depending on the values in each row. In SQL, we do this by using `case when [CONDITION] then [VALUE] else [DEFAULT VALUE] end`. We use `setseed` to keep the randomized numbers the same set.\n\n::: {#6dcf2d0a .cell execution_count=20}\n``` {.python .cell-code code-fold=\"show\"}\n#random is randomizing number between 0 and 1 then floor rounds it down\nquery = f\"\"\"\nselect setseed(0.112);\nselect \n *\n ,item_id % 1000 + 50 as price\n ,case when behavior_type = 'buy' then FLOOR(RANDOM() * 10) + 1 else null end as quantity\nfrom transaction_tbl\n\"\"\"\n\nexecute_query(query)\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>user_id</th>\n      <th>item_id</th>\n      <th>timestamp</th>\n      <th>behavior_type</th>\n      <th>category_id</th>\n      <th>price</th>\n      <th>quantity</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>184439</td>\n      <td>688483</td>\n      <td>1512105722</td>\n      <td>buy</td>\n      <td>1000858</td>\n      <td>533</td>\n      <td>2.0</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>860167</td>\n      <td>3032030</td>\n      <td>1511876592</td>\n      <td>pv</td>\n      <td>1000858</td>\n      <td>80</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>29019</td>\n      <td>1174848</td>\n      <td>1511952716</td>\n      <td>pv</td>\n      <td>1000858</td>\n      <td>898</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>...</th>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n    </tr>\n    <tr>\n      <th>4999997</th>\n      <td>461462</td>\n      <td>1642299</td>\n      <td>1511677441</td>\n      <td>pv</td>\n      <td>999980</td>\n      <td>349</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>4999998</th>\n      <td>891831</td>\n      <td>2064564</td>\n      <td>1512255716</td>\n      <td>pv</td>\n      <td>999980</td>\n      <td>614</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>4999999</th>\n      <td>10430</td>\n      <td>2006178</td>\n      <td>1512012994</td>\n      <td>pv</td>\n      <td>999980</td>\n      <td>228</td>\n      <td>NaN</td>\n    </tr>\n  </tbody>\n</table>\n<p>5000000 rows × 7 columns</p>\n</div>\n```\n:::\n:::\n\n\nWe can also have as many `when` as we want. If we want to explicitly state the conditions for all `behavior_type`, it will look something like:\n\n::: {#540aa603 .cell execution_count=21}\n``` {.python .cell-code code-fold=\"show\"}\nquery = f\"\"\"\nselect setseed(0.112);\n\nselect \n *\n ,item_id % 1000 + 50 as price\n ,case \n   when behavior_type = 'buy' then FLOOR(RANDOM() * 10) + 1 \n   when behavior_type = 'pv' then null\n   when behavior_type = 'cart' then null\n   when behavior_type = 'fav' then null\n   else null \n  end as quantity\nfrom transaction_tbl;\n\"\"\"\n\nexecute_query(query)\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>user_id</th>\n      <th>item_id</th>\n      <th>timestamp</th>\n      <th>behavior_type</th>\n      <th>category_id</th>\n      <th>price</th>\n      <th>quantity</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>184439</td>\n      <td>688483</td>\n      <td>1512105722</td>\n      <td>buy</td>\n      <td>1000858</td>\n      <td>533</td>\n      <td>4.0</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>860167</td>\n      <td>3032030</td>\n      <td>1511876592</td>\n      <td>pv</td>\n      <td>1000858</td>\n      <td>80</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>29019</td>\n      <td>1174848</td>\n      <td>1511952716</td>\n      <td>pv</td>\n      <td>1000858</td>\n      <td>898</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>...</th>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n    </tr>\n    <tr>\n      <th>4999997</th>\n      <td>461462</td>\n      <td>1642299</td>\n      <td>1511677441</td>\n      <td>pv</td>\n      <td>999980</td>\n      <td>349</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>4999998</th>\n      <td>891831</td>\n      <td>2064564</td>\n      <td>1512255716</td>\n      <td>pv</td>\n      <td>999980</td>\n      <td>614</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>4999999</th>\n      <td>10430</td>\n      <td>2006178</td>\n      <td>1512012994</td>\n      <td>pv</td>\n      <td>999980</td>\n      <td>228</td>\n      <td>NaN</td>\n    </tr>\n  </tbody>\n</table>\n<p>5000000 rows × 7 columns</p>\n</div>\n```\n:::\n:::\n\n\n### Example: Calculate `sales` by multiplying `price` and `quantity`\n\nWe can do operations among columns of the table. This example necessitates us to perform `select` twice: first to create `price` and `quantity`, then to create `sales` by multiplying them together. We do this by writing a subquery.\n\n::: {#a94bf415 .cell execution_count=22}\n``` {.python .cell-code code-fold=\"show\"}\nquery = f\"\"\"\nselect setseed(0.112);\n\nselect \n whatever_subquery_alias_you_want.*\n ,price * quantity as sales\nfrom \n(select \n *\n ,item_id % 1000 + 50 as price\n ,case when behavior_type = 'buy' then FLOOR(RANDOM() * 10) + 1 else null end as quantity\nfrom transaction_tbl) whatever_subquery_alias_you_want;\n\"\"\"\n\nexecute_query(query)\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>user_id</th>\n      <th>item_id</th>\n      <th>timestamp</th>\n      <th>behavior_type</th>\n      <th>category_id</th>\n      <th>price</th>\n      <th>quantity</th>\n      <th>sales</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>184439</td>\n      <td>688483</td>\n      <td>1512105722</td>\n      <td>buy</td>\n      <td>1000858</td>\n      <td>533</td>\n      <td>6.0</td>\n      <td>3198.0</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>860167</td>\n      <td>3032030</td>\n      <td>1511876592</td>\n      <td>pv</td>\n      <td>1000858</td>\n      <td>80</td>\n      <td>NaN</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>29019</td>\n      <td>1174848</td>\n      <td>1511952716</td>\n      <td>pv</td>\n      <td>1000858</td>\n      <td>898</td>\n      <td>NaN</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>...</th>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n    </tr>\n    <tr>\n      <th>4999997</th>\n      <td>461462</td>\n      <td>1642299</td>\n      <td>1511677441</td>\n      <td>pv</td>\n      <td>999980</td>\n      <td>349</td>\n      <td>NaN</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>4999998</th>\n      <td>891831</td>\n      <td>2064564</td>\n      <td>1512255716</td>\n      <td>pv</td>\n      <td>999980</td>\n      <td>614</td>\n      <td>NaN</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>4999999</th>\n      <td>10430</td>\n      <td>2006178</td>\n      <td>1512012994</td>\n      <td>pv</td>\n      <td>999980</td>\n      <td>228</td>\n      <td>NaN</td>\n      <td>NaN</td>\n    </tr>\n  </tbody>\n</table>\n<p>5000000 rows × 8 columns</p>\n</div>\n```\n:::\n:::\n\n\nYou would notice that the query becomes exponentially less readable with subqueries. This is especially the case when you have multiple nested subqueries and they become unreadable even by you in the next 3 months. An elegant solution is to separate these subqueries with `with` clauses. This is especially useful if you have a subquery you would like to reuse later in *the same query*. There is no performance difference between subqueries and `with` clauses, so pick what is easiest to read for you.\n\n::: {#e246a4a4 .cell execution_count=23}\n``` {.python .cell-code code-fold=\"show\"}\nquery = f\"\"\"\nselect setseed(0.112);\n\nwith t1_tbl as (\nselect \n *\n ,item_id % 1000 + 50 as price\n ,case when behavior_type = 'buy' then FLOOR(RANDOM() * 10) + 1 else null end as quantity\nfrom transaction_tbl\n)\n\nselect \n *\n ,price * quantity as sales\nfrom t1_tbl;\n\"\"\"\n\nexecute_query(query)\n```\n\n::: {.cell-output .cell-output-display execution_count=23}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>user_id</th>\n      <th>item_id</th>\n      <th>timestamp</th>\n      <th>behavior_type</th>\n      <th>category_id</th>\n      <th>price</th>\n      <th>quantity</th>\n      <th>sales</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>184439</td>\n      <td>688483</td>\n      <td>1512105722</td>\n      <td>buy</td>\n      <td>1000858</td>\n      <td>533</td>\n      <td>6.0</td>\n      <td>3198.0</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>860167</td>\n      <td>3032030</td>\n      <td>1511876592</td>\n      <td>pv</td>\n      <td>1000858</td>\n      <td>80</td>\n      <td>NaN</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>29019</td>\n      <td>1174848</td>\n      <td>1511952716</td>\n      <td>pv</td>\n      <td>1000858</td>\n      <td>898</td>\n      <td>NaN</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>...</th>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n    </tr>\n    <tr>\n      <th>4999997</th>\n      <td>461462</td>\n      <td>1642299</td>\n      <td>1511677441</td>\n      <td>pv</td>\n      <td>999980</td>\n      <td>349</td>\n      <td>NaN</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>4999998</th>\n      <td>891831</td>\n      <td>2064564</td>\n      <td>1512255716</td>\n      <td>pv</td>\n      <td>999980</td>\n      <td>614</td>\n      <td>NaN</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>4999999</th>\n      <td>10430</td>\n      <td>2006178</td>\n      <td>1512012994</td>\n      <td>pv</td>\n      <td>999980</td>\n      <td>228</td>\n      <td>NaN</td>\n      <td>NaN</td>\n    </tr>\n  </tbody>\n</table>\n<p>5000000 rows × 8 columns</p>\n</div>\n```\n:::\n:::\n\n\n### Example: Fill in missing values in `sales` with zero.\n\nWe use `coalesce` to fill in missing values. Notice that we can have multiple `with` clauses (consecutive ones puncutated by `,` and do not need `with`) depending on how you thin is most readable.\n\n::: {#6779ae4f .cell execution_count=24}\n``` {.python .cell-code code-fold=\"show\"}\nquery = f\"\"\"\nselect setseed(0.112);\n\nwith t1_tbl as (\nselect \n *\n ,item_id % 1000 + 50 as price\n ,case when behavior_type = 'buy' then FLOOR(RANDOM() * 10) + 1 else null end as quantity\nfrom transaction_tbl\n),\n\nt2_tbl as (\nselect \n *\n ,price * quantity as sales\nfrom t1_tbl\n)\n\nselect\n user_id\n ,item_id\n ,timestamp\n ,behavior_type\n ,category_id\n ,price\n ,quantity\n ,coalesce(sales, 0) as sales\nfrom t2_tbl;\n\"\"\"\n\nexecute_query(query)\n```\n\n::: {.cell-output .cell-output-display execution_count=24}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>user_id</th>\n      <th>item_id</th>\n      <th>timestamp</th>\n      <th>behavior_type</th>\n      <th>category_id</th>\n      <th>price</th>\n      <th>quantity</th>\n      <th>sales</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>184439</td>\n      <td>688483</td>\n      <td>1512105722</td>\n      <td>buy</td>\n      <td>1000858</td>\n      <td>533</td>\n      <td>2.0</td>\n      <td>1066.0</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>860167</td>\n      <td>3032030</td>\n      <td>1511876592</td>\n      <td>pv</td>\n      <td>1000858</td>\n      <td>80</td>\n      <td>NaN</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>29019</td>\n      <td>1174848</td>\n      <td>1511952716</td>\n      <td>pv</td>\n      <td>1000858</td>\n      <td>898</td>\n      <td>NaN</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>...</th>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n    </tr>\n    <tr>\n      <th>4999997</th>\n      <td>461462</td>\n      <td>1642299</td>\n      <td>1511677441</td>\n      <td>pv</td>\n      <td>999980</td>\n      <td>349</td>\n      <td>NaN</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>4999998</th>\n      <td>891831</td>\n      <td>2064564</td>\n      <td>1512255716</td>\n      <td>pv</td>\n      <td>999980</td>\n      <td>614</td>\n      <td>NaN</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>4999999</th>\n      <td>10430</td>\n      <td>2006178</td>\n      <td>1512012994</td>\n      <td>pv</td>\n      <td>999980</td>\n      <td>228</td>\n      <td>NaN</td>\n      <td>0.0</td>\n    </tr>\n  </tbody>\n</table>\n<p>5000000 rows × 8 columns</p>\n</div>\n```\n:::\n:::\n\n\n### Example: Convert timestamp from unix timestamp to `yyyy-mm-dd` format.\n\nDatetime conversion, as in any programming script, is a very confusing affair, so I highly recommend you refer to your specific SQL's documentation such as [this one for Spark](https://spark.apache.org/docs/latest/sql-ref-datetime-pattern.html). But the idea is simply applying some function over your columns. Here we use `to_timestamp` to convert from `int` to unix timestamp and then use `strftime` to convert to a string formatted as `yyyy-mm-dd`.\n\n::: {#0a09739d .cell execution_count=25}\n``` {.python .cell-code code-fold=\"show\"}\nquery = f\"\"\"\nselect setseed(0.112);\n\nwith t1_tbl as (\nselect \n *\n ,item_id % 1000 + 50 as price\n ,case when behavior_type = 'buy' then FLOOR(RANDOM() * 10) + 1 else null end as quantity\nfrom transaction_tbl\n),\n\nt2_tbl as (\nselect \n *\n ,price * quantity as sales\nfrom t1_tbl\n),\n\nt3_tbl as (\nselect\n user_id\n ,item_id\n ,timestamp\n ,behavior_type\n ,category_id\n ,price\n ,quantity\n ,coalesce(sales, 0) as sales\nfrom t2_tbl)\n\nselect\n *\n ,to_timestamp(timestamp) as event_timestamp\n ,strftime(to_timestamp(timestamp), '%Y-%m-%d') as event_date\nfrom t3_tbl;\n\"\"\"\n\nexecute_query(query)\n```\n\n::: {.cell-output .cell-output-display execution_count=25}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>user_id</th>\n      <th>item_id</th>\n      <th>timestamp</th>\n      <th>behavior_type</th>\n      <th>category_id</th>\n      <th>price</th>\n      <th>quantity</th>\n      <th>sales</th>\n      <th>event_timestamp</th>\n      <th>event_date</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>184439</td>\n      <td>688483</td>\n      <td>1512105722</td>\n      <td>buy</td>\n      <td>1000858</td>\n      <td>533</td>\n      <td>5.0</td>\n      <td>2665.0</td>\n      <td>2017-12-01 14:22:02+09:00</td>\n      <td>2017-12-01</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>860167</td>\n      <td>3032030</td>\n      <td>1511876592</td>\n      <td>pv</td>\n      <td>1000858</td>\n      <td>80</td>\n      <td>NaN</td>\n      <td>0.0</td>\n      <td>2017-11-28 22:43:12+09:00</td>\n      <td>2017-11-28</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>29019</td>\n      <td>1174848</td>\n      <td>1511952716</td>\n      <td>pv</td>\n      <td>1000858</td>\n      <td>898</td>\n      <td>NaN</td>\n      <td>0.0</td>\n      <td>2017-11-29 19:51:56+09:00</td>\n      <td>2017-11-29</td>\n    </tr>\n    <tr>\n      <th>...</th>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n    </tr>\n    <tr>\n      <th>4999997</th>\n      <td>461462</td>\n      <td>1642299</td>\n      <td>1511677441</td>\n      <td>pv</td>\n      <td>999980</td>\n      <td>349</td>\n      <td>NaN</td>\n      <td>0.0</td>\n      <td>2017-11-26 15:24:01+09:00</td>\n      <td>2017-11-26</td>\n    </tr>\n    <tr>\n      <th>4999998</th>\n      <td>891831</td>\n      <td>2064564</td>\n      <td>1512255716</td>\n      <td>pv</td>\n      <td>999980</td>\n      <td>614</td>\n      <td>NaN</td>\n      <td>0.0</td>\n      <td>2017-12-03 08:01:56+09:00</td>\n      <td>2017-12-03</td>\n    </tr>\n    <tr>\n      <th>4999999</th>\n      <td>10430</td>\n      <td>2006178</td>\n      <td>1512012994</td>\n      <td>pv</td>\n      <td>999980</td>\n      <td>228</td>\n      <td>NaN</td>\n      <td>0.0</td>\n      <td>2017-11-30 12:36:34+09:00</td>\n      <td>2017-11-30</td>\n    </tr>\n  </tbody>\n</table>\n<p>5000000 rows × 10 columns</p>\n</div>\n```\n:::\n:::\n\n\n### Example: Make a string column `year_month` that takes only the `yyyy-mm` part from `event_timestamp`.\n\nMost query engines have built-in functions to manipulate texts such as [this one for duckdb](https://duckdb.org/docs/stable/sql/functions/text.html). However, in this case, since `event_timestamp` is a timestmap, we need to convert its data type to string before applying the function `substring` by using `cast([COLUMN] as [DATA TYPE])`.\n\n::: {#af7584e4 .cell execution_count=26}\n``` {.python .cell-code code-fold=\"show\"}\nquery = f\"\"\"\nselect setseed(0.112);\n\nwith t1_tbl as (\nselect \n *\n ,item_id % 1000 + 50 as price\n ,case when behavior_type = 'buy' then FLOOR(RANDOM() * 10) + 1 else null end as quantity\nfrom transaction_tbl\n),\n\nt2_tbl as (\nselect \n *\n ,price * quantity as sales\nfrom t1_tbl\n),\n\nt3_tbl as (\nselect\n user_id\n ,item_id\n ,timestamp\n ,behavior_type\n ,category_id\n ,price\n ,quantity\n ,coalesce(sales, 0) as sales\nfrom t2_tbl),\n\nt4_tbl as (\nselect\n *\n ,to_timestamp(timestamp) as event_timestamp\n ,strftime(to_timestamp(timestamp), '%Y-%m-%d') as event_date\nfrom t3_tbl)\n\nselect\n *\n ,substring(cast(event_timestamp as varchar),1,7) as year_month\nfrom t4_tbl;\n\"\"\"\n\nexecute_query(query)\n```\n\n::: {.cell-output .cell-output-display execution_count=26}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>user_id</th>\n      <th>item_id</th>\n      <th>timestamp</th>\n      <th>behavior_type</th>\n      <th>category_id</th>\n      <th>price</th>\n      <th>quantity</th>\n      <th>sales</th>\n      <th>event_timestamp</th>\n      <th>event_date</th>\n      <th>year_month</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>184439</td>\n      <td>688483</td>\n      <td>1512105722</td>\n      <td>buy</td>\n      <td>1000858</td>\n      <td>533</td>\n      <td>5.0</td>\n      <td>2665.0</td>\n      <td>2017-12-01 14:22:02+09:00</td>\n      <td>2017-12-01</td>\n      <td>2017-12</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>860167</td>\n      <td>3032030</td>\n      <td>1511876592</td>\n      <td>pv</td>\n      <td>1000858</td>\n      <td>80</td>\n      <td>NaN</td>\n      <td>0.0</td>\n      <td>2017-11-28 22:43:12+09:00</td>\n      <td>2017-11-28</td>\n      <td>2017-11</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>29019</td>\n      <td>1174848</td>\n      <td>1511952716</td>\n      <td>pv</td>\n      <td>1000858</td>\n      <td>898</td>\n      <td>NaN</td>\n      <td>0.0</td>\n      <td>2017-11-29 19:51:56+09:00</td>\n      <td>2017-11-29</td>\n      <td>2017-11</td>\n    </tr>\n    <tr>\n      <th>...</th>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n    </tr>\n    <tr>\n      <th>4999997</th>\n      <td>461462</td>\n      <td>1642299</td>\n      <td>1511677441</td>\n      <td>pv</td>\n      <td>999980</td>\n      <td>349</td>\n      <td>NaN</td>\n      <td>0.0</td>\n      <td>2017-11-26 15:24:01+09:00</td>\n      <td>2017-11-26</td>\n      <td>2017-11</td>\n    </tr>\n    <tr>\n      <th>4999998</th>\n      <td>891831</td>\n      <td>2064564</td>\n      <td>1512255716</td>\n      <td>pv</td>\n      <td>999980</td>\n      <td>614</td>\n      <td>NaN</td>\n      <td>0.0</td>\n      <td>2017-12-03 08:01:56+09:00</td>\n      <td>2017-12-03</td>\n      <td>2017-12</td>\n    </tr>\n    <tr>\n      <th>4999999</th>\n      <td>10430</td>\n      <td>2006178</td>\n      <td>1512012994</td>\n      <td>pv</td>\n      <td>999980</td>\n      <td>228</td>\n      <td>NaN</td>\n      <td>0.0</td>\n      <td>2017-11-30 12:36:34+09:00</td>\n      <td>2017-11-30</td>\n      <td>2017-11</td>\n    </tr>\n  </tbody>\n</table>\n<p>5000000 rows × 11 columns</p>\n</div>\n```\n:::\n:::\n\n\n### Example: Save the manipulations done so far as a `view` to be used later.\n\nYou'll notice that even with the `with` clauses, our query seems substantially more clunky now. We do not want to be re-writing these lines every time we reuse this set of results for other queries. Luckily, there is a solution called `view`. A view saves the query logic that can be used for other queries later. Unlike actual SQL tables, the data are not stored physically on your database, so the query saved to a view will still run every time it is called.\n\nThis query creates the view:\n\n::: {#d5b3d29b .cell execution_count=27}\n``` {.python .cell-code code-fold=\"show\"}\nquery = f\"\"\"\nselect setseed(0.112);\n\ncreate or replace view transaction_tbl_x as (\n\nwith t1_tbl as (\nselect \n *\n ,item_id % 1000 + 50 as price\n ,case when behavior_type = 'buy' then FLOOR(RANDOM() * 10) + 1 else null end as quantity\nfrom transaction_tbl\n),\n\nt2_tbl as (\nselect \n *\n ,price * quantity as sales\nfrom t1_tbl\n),\n\nt3_tbl as (\nselect\n user_id\n ,item_id\n ,timestamp\n ,behavior_type\n ,category_id\n ,price\n ,quantity\n ,coalesce(sales, 0) as sales\nfrom t2_tbl),\n\nt4_tbl as (\nselect\n *\n ,to_timestamp(timestamp) as event_timestamp\n ,strftime(to_timestamp(timestamp), '%Y-%m-%d') as event_date\nfrom t3_tbl)\n\nselect\n *\n ,substring(cast(event_timestamp as varchar),1,7) as year_month\nfrom t4_tbl\n)\n\"\"\"\n\nexecute_query(query)\n```\n\n::: {.cell-output .cell-output-display execution_count=27}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Count</th>\n    </tr>\n  </thead>\n  <tbody>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nThis query reuses it by a simple `select *`:\n\n::: {#24e4367d .cell execution_count=28}\n``` {.python .cell-code code-fold=\"show\"}\nquery = f\"\"\"\nselect setseed(0.112);\n\nselect * from transaction_tbl_x limit 100;\n\"\"\"\n\nexecute_query(query)\n```\n\n::: {.cell-output .cell-output-display execution_count=28}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>user_id</th>\n      <th>item_id</th>\n      <th>timestamp</th>\n      <th>behavior_type</th>\n      <th>category_id</th>\n      <th>price</th>\n      <th>quantity</th>\n      <th>sales</th>\n      <th>event_timestamp</th>\n      <th>event_date</th>\n      <th>year_month</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>184439</td>\n      <td>688483</td>\n      <td>1512105722</td>\n      <td>buy</td>\n      <td>1000858</td>\n      <td>533</td>\n      <td>5.0</td>\n      <td>2665.0</td>\n      <td>2017-12-01 14:22:02+09:00</td>\n      <td>2017-12-01</td>\n      <td>2017-12</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>860167</td>\n      <td>3032030</td>\n      <td>1511876592</td>\n      <td>pv</td>\n      <td>1000858</td>\n      <td>80</td>\n      <td>NaN</td>\n      <td>0.0</td>\n      <td>2017-11-28 22:43:12+09:00</td>\n      <td>2017-11-28</td>\n      <td>2017-11</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>29019</td>\n      <td>1174848</td>\n      <td>1511952716</td>\n      <td>pv</td>\n      <td>1000858</td>\n      <td>898</td>\n      <td>NaN</td>\n      <td>0.0</td>\n      <td>2017-11-29 19:51:56+09:00</td>\n      <td>2017-11-29</td>\n      <td>2017-11</td>\n    </tr>\n    <tr>\n      <th>...</th>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n    </tr>\n    <tr>\n      <th>97</th>\n      <td>109393</td>\n      <td>336502</td>\n      <td>1512302682</td>\n      <td>pv</td>\n      <td>1003726</td>\n      <td>552</td>\n      <td>NaN</td>\n      <td>0.0</td>\n      <td>2017-12-03 21:04:42+09:00</td>\n      <td>2017-12-03</td>\n      <td>2017-12</td>\n    </tr>\n    <tr>\n      <th>98</th>\n      <td>928768</td>\n      <td>2826670</td>\n      <td>1511780591</td>\n      <td>pv</td>\n      <td>1003726</td>\n      <td>720</td>\n      <td>NaN</td>\n      <td>0.0</td>\n      <td>2017-11-27 20:03:11+09:00</td>\n      <td>2017-11-27</td>\n      <td>2017-11</td>\n    </tr>\n    <tr>\n      <th>99</th>\n      <td>719622</td>\n      <td>2297792</td>\n      <td>1511703912</td>\n      <td>pv</td>\n      <td>1003726</td>\n      <td>842</td>\n      <td>NaN</td>\n      <td>0.0</td>\n      <td>2017-11-26 22:45:12+09:00</td>\n      <td>2017-11-26</td>\n      <td>2017-11</td>\n    </tr>\n  </tbody>\n</table>\n<p>100 rows × 11 columns</p>\n</div>\n```\n:::\n:::\n\n\n## 5. Aggregation aka Group By\n\nWhen you have millions of rows of data, you do not want to look at them one by one; you want to know how they appear in aggregateーhow many events there are for each type, which items are favorited the most/least, how many items users buy on average, and so on. In fact, you have already learned how to do some of this. `count` and `count(distinct [COLUMN])` are examples of aggregation over the entire table. In this section, we will also learn to use `group by` to get aggregated values according to the columns we want.\n\n### Example: How many events are there for each event type (`behavior_type`)?\n\nYou can order by the newly created `nb_event` column to sort event types in descending order according to how many events they have. As expected, it is views, add-to-carts, favorites, then purchases.\n\n::: {#32510a06 .cell execution_count=29}\n``` {.python .cell-code code-fold=\"show\"}\nquery = f\"\"\"\nselect setseed(0.112);\n\nselect \n behavior_type\n ,count(*) as nb_event\nfrom transaction_tbl_x\ngroup by behavior_type\norder by nb_event desc;\n\"\"\"\n\nexecute_query(query)\n```\n\n::: {.cell-output .cell-output-display execution_count=29}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>behavior_type</th>\n      <th>nb_event</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>pv</td>\n      <td>4478549</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>cart</td>\n      <td>276307</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>fav</td>\n      <td>144452</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>buy</td>\n      <td>100692</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nOne neat trick is that you do not have to write the column names in `group by` or `order by` and use numbering instead; for instance, 1 means the first column selected, in this case `behavior_type`.\n\n::: {#f6b41d05 .cell execution_count=30}\n``` {.python .cell-code code-fold=\"show\"}\nquery = f\"\"\"\nselect setseed(0.112);\n\nselect \n behavior_type\n ,count(*) as nb_event\nfrom transaction_tbl_x\ngroup by 1\norder by 2 desc;\n\"\"\"\n\nexecute_query(query)\n```\n\n::: {.cell-output .cell-output-display execution_count=30}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>behavior_type</th>\n      <th>nb_event</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>pv</td>\n      <td>4478549</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>cart</td>\n      <td>276307</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>fav</td>\n      <td>144452</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>buy</td>\n      <td>100692</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n### Example: What are the top 10 items that got favorited by most number of unique customers?\n\nWhen used in conjunction with `where`, the `where` clause comes before `group by`.\n\n::: {#e9eebc5e .cell execution_count=31}\n``` {.python .cell-code code-fold=\"show\"}\nquery = f\"\"\"\nselect setseed(0.112);\n\nselect \n item_id\n ,count(distinct user_id) as nb_user\nfrom transaction_tbl_x\nwhere behavior_type = 'fav'\ngroup by 1\norder by 2 desc\nlimit 10;\n\"\"\"\n\nexecute_query(query)\n```\n\n::: {.cell-output .cell-output-display execution_count=31}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>item_id</th>\n      <th>nb_user</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>2331370</td>\n      <td>43</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>3845720</td>\n      <td>41</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>2279428</td>\n      <td>40</td>\n    </tr>\n    <tr>\n      <th>...</th>\n      <td>...</td>\n      <td>...</td>\n    </tr>\n    <tr>\n      <th>7</th>\n      <td>2364679</td>\n      <td>37</td>\n    </tr>\n    <tr>\n      <th>8</th>\n      <td>3403645</td>\n      <td>35</td>\n    </tr>\n    <tr>\n      <th>9</th>\n      <td>1783990</td>\n      <td>33</td>\n    </tr>\n  </tbody>\n</table>\n<p>10 rows × 2 columns</p>\n</div>\n```\n:::\n:::\n\n\n### Example: What is the average, standard deviation, min, and max spend per user?\n\nFirst, we need to `sum` up all `sales` for each user then perform the `avg`, `stddev`, `min` and `max` aggregation over all users. We can also see quantiles using functions like `approx_quantile([COLUMN], [QUANTILE])`.\n\n::: {#012d8108 .cell execution_count=32}\n``` {.python .cell-code code-fold=\"show\"}\nquery = f\"\"\"\nselect setseed(0.112);\n\nselect\n min(spend) as min_spend\n ,approx_quantile(spend, 0.25) as p25\n ,avg(spend) as avg_spend\n ,stddev(spend) as std_spend\n ,approx_quantile(spend, 0.5) as p50\n ,approx_quantile(spend, 0.75) as p75\n ,max(spend) as max_spend\nfrom\n(select \n user_id\n ,sum(sales) as spend\nfrom transaction_tbl_x\ngroup by 1\n) a;\n\"\"\"\n\nexecute_query(query)\n```\n\n::: {.cell-output .cell-output-display execution_count=32}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>min_spend</th>\n      <th>p25</th>\n      <th>avg_spend</th>\n      <th>std_spend</th>\n      <th>p50</th>\n      <th>p75</th>\n      <th>max_spend</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>343.119825</td>\n      <td>1343.99162</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>33513.0</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n### Example: How many percentage of customer purchased at least once?\n\nAs you might notice from the last example, most of the customers have spend equals zero. This is a typical distribution in a retail business where most users come to window shop and only a few will make a purchase. We can find out % of those who made at least one purchase by combining `avg` aggregation and the `case when` if-else logic.\n\n::: {#212bcf8f .cell execution_count=33}\n``` {.python .cell-code code-fold=\"show\"}\nquery = f\"\"\"\nselect setseed(0.112);\n\nselect\n avg(case when spend > 0 then 1 else 0 end) as conversion_rate\nfrom\n(select \n user_id\n ,sum(sales) as spend\nfrom transaction_tbl_x\ngroup by 1\n) a;\n\"\"\"\n\nexecute_query(query)\n```\n\n::: {.cell-output .cell-output-display execution_count=33}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>conversion_rate</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>0.102035</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n### Example: Give me only customers who have bought at least one item more expensive than $100.\n\nIn the same manner we use `where` clause to filter `select`, we can also use `having` to filter aggregations. This works exactly the same where as how you would do aggregation first then filter it with a subquery. Most modern query engines treat them the same way in terms of performance so pick whichever is more readable to you.\n\n::: {#f9c3e3be .cell execution_count=34}\n``` {.python .cell-code code-fold=\"show\"}\nquery = f\"\"\"\nselect setseed(0.112);\n\nselect \n user_id\n ,min(price) as min_price\nfrom transaction_tbl_x\nwhere behavior_type = 'buy'\ngroup by 1\nhaving min_price > 100\norder by min_price;\n\"\"\"\n\nexecute_query(query)\n```\n\n::: {.cell-output .cell-output-display execution_count=34}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>user_id</th>\n      <th>min_price</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>782669</td>\n      <td>101</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>302287</td>\n      <td>101</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>773094</td>\n      <td>101</td>\n    </tr>\n    <tr>\n      <th>...</th>\n      <td>...</td>\n      <td>...</td>\n    </tr>\n    <tr>\n      <th>85577</th>\n      <td>340274</td>\n      <td>1049</td>\n    </tr>\n    <tr>\n      <th>85578</th>\n      <td>603498</td>\n      <td>1049</td>\n    </tr>\n    <tr>\n      <th>85579</th>\n      <td>438867</td>\n      <td>1049</td>\n    </tr>\n  </tbody>\n</table>\n<p>85580 rows × 2 columns</p>\n</div>\n```\n:::\n:::\n\n\n### Example: For each user who have favorited anything, give me a list of items they have favorited ordered by timestamp in ascending order.\n\nToday you might run into preparing a sequence dataset to train LLMs, in which case you want to concatenate a series of values from a column. Most modern SQL handles this such as [Spark SQL](https://spark.apache.org/docs/latest/sql-ref-functions-builtin.html#array-functions) and [Presto](https://prestodb.io/docs/current/functions/array.html). In duckdb, we can use `string_agg` and keep order from earliest to latest timestamp by using `order by`.\n\n::: {#c3582d76 .cell execution_count=35}\n``` {.python .cell-code code-fold=\"show\"}\nquery = f\"\"\"\nselect setseed(0.112);\n\nselect \n user_id\n ,string_agg(item_id order by timestamp) as item_id_list\nfrom transaction_tbl_x\nwhere behavior_type = 'fav'\ngroup by 1\n\"\"\"\n\nexecute_query(query)\n```\n\n::: {.cell-output .cell-output-display execution_count=35}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>user_id</th>\n      <th>item_id_list</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>744534</td>\n      <td>2149136,88810,4629792</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>517461</td>\n      <td>4325698,5109079,2036947</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>261004</td>\n      <td>1289993,4431704</td>\n    </tr>\n    <tr>\n      <th>...</th>\n      <td>...</td>\n      <td>...</td>\n    </tr>\n    <tr>\n      <th>98434</th>\n      <td>702058</td>\n      <td>4753515</td>\n    </tr>\n    <tr>\n      <th>98435</th>\n      <td>865408</td>\n      <td>2643630</td>\n    </tr>\n    <tr>\n      <th>98436</th>\n      <td>391171</td>\n      <td>5154868</td>\n    </tr>\n  </tbody>\n</table>\n<p>98437 rows × 2 columns</p>\n</div>\n```\n:::\n:::\n\n\n## 6. Window Function\n\nAggregation is very powerful, but a major downside is that it collapses the total rows into aggregated values. This means that after using `group by`, you lose the individual detail of each original row. You can no longer easily ask questions about the sequence of events, like \"What happened just before this?\" or \"What is the third item in this list?\". Window functions solve this by allowing you to perform calculations on a related set of rows (a \"window\") without making those rows disappear. They let you calculate things like rankings, running totals, or compare values across rows, all while keeping all your original data rows intact.\n\n### Example: For each user, find their second-to-last event.\n\nWe might be able to use `min/max` aggregation with some subqueries to get the last event, but second-to-last event is a bit convoluted to retrieve with `group by` alone. This is trivial when we use `row_number() over (partition by [WINDOW COLUMN] order by [ORDERING COLUMN] asc/desc)` to get the ranking numbers (starting with 1), then filter only the rows we need (`rnk=2`).\n\n::: {#e6814a5d .cell execution_count=36}\n``` {.python .cell-code code-fold=\"show\"}\nquery = f\"\"\"\nselect setseed(0.112);\n\nselect * from\n(select \n *\n ,row_number() over (partition by user_id order by timestamp desc) as rnk\nfrom transaction_tbl_x) a\nwhere rnk=2\n\"\"\"\n\nexecute_query(query)\n```\n\n::: {.cell-output .cell-output-display execution_count=36}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>user_id</th>\n      <th>item_id</th>\n      <th>timestamp</th>\n      <th>behavior_type</th>\n      <th>category_id</th>\n      <th>price</th>\n      <th>quantity</th>\n      <th>sales</th>\n      <th>event_timestamp</th>\n      <th>event_date</th>\n      <th>year_month</th>\n      <th>rnk</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>6</td>\n      <td>730246</td>\n      <td>1512151025</td>\n      <td>pv</td>\n      <td>4756105</td>\n      <td>296</td>\n      <td>NaN</td>\n      <td>0.0</td>\n      <td>2017-12-02 02:57:05+09:00</td>\n      <td>2017-12-02</td>\n      <td>2017-12</td>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>58</td>\n      <td>274807</td>\n      <td>1512191821</td>\n      <td>pv</td>\n      <td>4458428</td>\n      <td>857</td>\n      <td>NaN</td>\n      <td>0.0</td>\n      <td>2017-12-02 14:17:01+09:00</td>\n      <td>2017-12-02</td>\n      <td>2017-12</td>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>73</td>\n      <td>2561888</td>\n      <td>1512224052</td>\n      <td>pv</td>\n      <td>753984</td>\n      <td>938</td>\n      <td>NaN</td>\n      <td>0.0</td>\n      <td>2017-12-02 23:14:12+09:00</td>\n      <td>2017-12-02</td>\n      <td>2017-12</td>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>...</th>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n    </tr>\n    <tr>\n      <th>753406</th>\n      <td>1017789</td>\n      <td>797757</td>\n      <td>1512179970</td>\n      <td>pv</td>\n      <td>883960</td>\n      <td>807</td>\n      <td>NaN</td>\n      <td>0.0</td>\n      <td>2017-12-02 10:59:30+09:00</td>\n      <td>2017-12-02</td>\n      <td>2017-12</td>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>753407</th>\n      <td>1017827</td>\n      <td>4777442</td>\n      <td>1512258856</td>\n      <td>pv</td>\n      <td>3607361</td>\n      <td>492</td>\n      <td>NaN</td>\n      <td>0.0</td>\n      <td>2017-12-03 08:54:16+09:00</td>\n      <td>2017-12-03</td>\n      <td>2017-12</td>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>753408</th>\n      <td>1017858</td>\n      <td>850224</td>\n      <td>1512291735</td>\n      <td>pv</td>\n      <td>3800818</td>\n      <td>274</td>\n      <td>NaN</td>\n      <td>0.0</td>\n      <td>2017-12-03 18:02:15+09:00</td>\n      <td>2017-12-03</td>\n      <td>2017-12</td>\n      <td>2</td>\n    </tr>\n  </tbody>\n</table>\n<p>753409 rows × 12 columns</p>\n</div>\n```\n:::\n:::\n\n\nWe can confirm that these are one second-to-last event each from users who have a least 2 events.\n\n::: {#311c309b .cell execution_count=37}\n``` {.python .cell-code code-fold=\"show\"}\nquery = f\"\"\"\nselect setseed(0.112);\n\nselect count(*) from\n(select \n user_id\n ,count(*) nb\nfrom transaction_tbl_x\ngroup by 1) a\nwhere nb>=2\n\"\"\"\n\nexecute_query(query)\n```\n\n::: {.cell-output .cell-output-display execution_count=37}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>count_star()</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>753409</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n### Example: What is the first item in each category that each user view?\n\nWe can also have multiple partitions as window.\n\n::: {#4eea2b0b .cell execution_count=38}\n``` {.python .cell-code code-fold=\"show\"}\nquery = f\"\"\"\nselect setseed(0.112);\n\nselect * from\n(select \n user_id\n ,item_id\n ,row_number() over (partition by user_id, category_id order by timestamp asc) as rnk\nfrom transaction_tbl_x\nwhere behavior_type = 'pv') a\nwhere rnk=1;\n\"\"\"\n\nexecute_query(query)\n```\n\n::: {.cell-output .cell-output-display execution_count=38}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>user_id</th>\n      <th>item_id</th>\n      <th>rnk</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>7</td>\n      <td>516760</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>19</td>\n      <td>3615870</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>21</td>\n      <td>4928897</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>...</th>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n    </tr>\n    <tr>\n      <th>3389298</th>\n      <td>1017999</td>\n      <td>3251062</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>3389299</th>\n      <td>1018006</td>\n      <td>2789562</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>3389300</th>\n      <td>1018011</td>\n      <td>3190817</td>\n      <td>1</td>\n    </tr>\n  </tbody>\n</table>\n<p>3389301 rows × 3 columns</p>\n</div>\n```\n:::\n:::\n\n\n### Example: For each user, what was their previous action before a `buy` action?\n\nWe can use `lag/lead` to get value just before or after each row.\n\n::: {#20f59cfd .cell execution_count=39}\n``` {.python .cell-code code-fold=\"show\"}\npd.set_option('display.max_rows', 10) \n\nquery = f\"\"\"\nselect setseed(0.112);\n\nselect * from \n(select\n    user_id,\n    event_timestamp,\n    behavior_type as current_event,\n    lag(behavior_type) over (partition by user_id order by event_timestamp asc) as previous_event\nfrom transaction_tbl_x\norder by user_id, event_timestamp asc) a\nwhere current_event = 'buy'\nlimit 10\n\"\"\"\n\nexecute_query(query)\n```\n\n::: {.cell-output .cell-output-display execution_count=39}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>user_id</th>\n      <th>event_timestamp</th>\n      <th>current_event</th>\n      <th>previous_event</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>2</td>\n      <td>2017-12-02 20:34:34+09:00</td>\n      <td>buy</td>\n      <td>pv</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>41</td>\n      <td>2017-11-28 15:22:28+09:00</td>\n      <td>buy</td>\n      <td>pv</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>45</td>\n      <td>2017-12-03 11:49:02+09:00</td>\n      <td>buy</td>\n      <td>pv</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>50</td>\n      <td>2017-11-27 09:02:55+09:00</td>\n      <td>buy</td>\n      <td>None</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>50</td>\n      <td>2017-12-02 11:35:55+09:00</td>\n      <td>buy</td>\n      <td>pv</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>50</td>\n      <td>2017-12-03 20:56:57+09:00</td>\n      <td>buy</td>\n      <td>buy</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>59</td>\n      <td>2017-11-27 01:29:32+09:00</td>\n      <td>buy</td>\n      <td>pv</td>\n    </tr>\n    <tr>\n      <th>7</th>\n      <td>62</td>\n      <td>2017-12-03 16:30:30+09:00</td>\n      <td>buy</td>\n      <td>pv</td>\n    </tr>\n    <tr>\n      <th>8</th>\n      <td>68</td>\n      <td>2017-11-27 19:59:34+09:00</td>\n      <td>buy</td>\n      <td>pv</td>\n    </tr>\n    <tr>\n      <th>9</th>\n      <td>80</td>\n      <td>2017-11-25 22:52:00+09:00</td>\n      <td>buy</td>\n      <td>pv</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nConfirm the query works by looking at `user_id=50` (no event, `pv`, `buy`) and `user_id=41` (single `pv` event).\n\n::: {#eb5801bf .cell execution_count=40}\n``` {.python .cell-code code-fold=\"show\"}\npd.set_option('display.max_rows', 30) \n\nquery = f\"\"\"\nselect setseed(0.112);\n\nselect\n *\nfrom transaction_tbl_x\nwhere user_id in (50, 41)\norder by user_id, event_timestamp\n\"\"\"\n\nexecute_query(query)\n```\n\n::: {.cell-output .cell-output-display execution_count=40}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>user_id</th>\n      <th>item_id</th>\n      <th>timestamp</th>\n      <th>behavior_type</th>\n      <th>category_id</th>\n      <th>price</th>\n      <th>quantity</th>\n      <th>sales</th>\n      <th>event_timestamp</th>\n      <th>event_date</th>\n      <th>year_month</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>41</td>\n      <td>2350782</td>\n      <td>1511590506</td>\n      <td>fav</td>\n      <td>3576283</td>\n      <td>832</td>\n      <td>NaN</td>\n      <td>0.0</td>\n      <td>2017-11-25 15:15:06+09:00</td>\n      <td>2017-11-25</td>\n      <td>2017-11</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>41</td>\n      <td>4810522</td>\n      <td>1511592979</td>\n      <td>pv</td>\n      <td>1464116</td>\n      <td>572</td>\n      <td>NaN</td>\n      <td>0.0</td>\n      <td>2017-11-25 15:56:19+09:00</td>\n      <td>2017-11-25</td>\n      <td>2017-11</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>41</td>\n      <td>259923</td>\n      <td>1511651601</td>\n      <td>pv</td>\n      <td>4170419</td>\n      <td>973</td>\n      <td>NaN</td>\n      <td>0.0</td>\n      <td>2017-11-26 08:13:21+09:00</td>\n      <td>2017-11-26</td>\n      <td>2017-11</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>41</td>\n      <td>4786486</td>\n      <td>1511758455</td>\n      <td>pv</td>\n      <td>2572604</td>\n      <td>536</td>\n      <td>NaN</td>\n      <td>0.0</td>\n      <td>2017-11-27 13:54:15+09:00</td>\n      <td>2017-11-27</td>\n      <td>2017-11</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>41</td>\n      <td>460114</td>\n      <td>1511850148</td>\n      <td>buy</td>\n      <td>4804883</td>\n      <td>164</td>\n      <td>5.0</td>\n      <td>820.0</td>\n      <td>2017-11-28 15:22:28+09:00</td>\n      <td>2017-11-28</td>\n      <td>2017-11</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>41</td>\n      <td>1876500</td>\n      <td>1511850397</td>\n      <td>pv</td>\n      <td>3158249</td>\n      <td>550</td>\n      <td>NaN</td>\n      <td>0.0</td>\n      <td>2017-11-28 15:26:37+09:00</td>\n      <td>2017-11-28</td>\n      <td>2017-11</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>41</td>\n      <td>3599288</td>\n      <td>1512050217</td>\n      <td>cart</td>\n      <td>1537669</td>\n      <td>338</td>\n      <td>NaN</td>\n      <td>0.0</td>\n      <td>2017-11-30 22:56:57+09:00</td>\n      <td>2017-11-30</td>\n      <td>2017-11</td>\n    </tr>\n    <tr>\n      <th>7</th>\n      <td>41</td>\n      <td>2479959</td>\n      <td>1512050346</td>\n      <td>pv</td>\n      <td>3491350</td>\n      <td>1009</td>\n      <td>NaN</td>\n      <td>0.0</td>\n      <td>2017-11-30 22:59:06+09:00</td>\n      <td>2017-11-30</td>\n      <td>2017-11</td>\n    </tr>\n    <tr>\n      <th>8</th>\n      <td>41</td>\n      <td>3095445</td>\n      <td>1512072759</td>\n      <td>fav</td>\n      <td>4801426</td>\n      <td>495</td>\n      <td>NaN</td>\n      <td>0.0</td>\n      <td>2017-12-01 05:12:39+09:00</td>\n      <td>2017-12-01</td>\n      <td>2017-12</td>\n    </tr>\n    <tr>\n      <th>9</th>\n      <td>41</td>\n      <td>3937435</td>\n      <td>1512072770</td>\n      <td>pv</td>\n      <td>4801426</td>\n      <td>485</td>\n      <td>NaN</td>\n      <td>0.0</td>\n      <td>2017-12-01 05:12:50+09:00</td>\n      <td>2017-12-01</td>\n      <td>2017-12</td>\n    </tr>\n    <tr>\n      <th>10</th>\n      <td>41</td>\n      <td>2601044</td>\n      <td>1512073082</td>\n      <td>pv</td>\n      <td>2735466</td>\n      <td>94</td>\n      <td>NaN</td>\n      <td>0.0</td>\n      <td>2017-12-01 05:18:02+09:00</td>\n      <td>2017-12-01</td>\n      <td>2017-12</td>\n    </tr>\n    <tr>\n      <th>11</th>\n      <td>41</td>\n      <td>3017816</td>\n      <td>1512073131</td>\n      <td>pv</td>\n      <td>2735466</td>\n      <td>866</td>\n      <td>NaN</td>\n      <td>0.0</td>\n      <td>2017-12-01 05:18:51+09:00</td>\n      <td>2017-12-01</td>\n      <td>2017-12</td>\n    </tr>\n    <tr>\n      <th>12</th>\n      <td>41</td>\n      <td>3976745</td>\n      <td>1512073512</td>\n      <td>pv</td>\n      <td>3002561</td>\n      <td>795</td>\n      <td>NaN</td>\n      <td>0.0</td>\n      <td>2017-12-01 05:25:12+09:00</td>\n      <td>2017-12-01</td>\n      <td>2017-12</td>\n    </tr>\n    <tr>\n      <th>13</th>\n      <td>50</td>\n      <td>1808993</td>\n      <td>1511740975</td>\n      <td>buy</td>\n      <td>4690421</td>\n      <td>1043</td>\n      <td>10.0</td>\n      <td>10430.0</td>\n      <td>2017-11-27 09:02:55+09:00</td>\n      <td>2017-11-27</td>\n      <td>2017-11</td>\n    </tr>\n    <tr>\n      <th>14</th>\n      <td>50</td>\n      <td>1353441</td>\n      <td>1511743131</td>\n      <td>cart</td>\n      <td>64179</td>\n      <td>491</td>\n      <td>NaN</td>\n      <td>0.0</td>\n      <td>2017-11-27 09:38:51+09:00</td>\n      <td>2017-11-27</td>\n      <td>2017-11</td>\n    </tr>\n    <tr>\n      <th>15</th>\n      <td>50</td>\n      <td>1963474</td>\n      <td>1511743387</td>\n      <td>pv</td>\n      <td>3422001</td>\n      <td>524</td>\n      <td>NaN</td>\n      <td>0.0</td>\n      <td>2017-11-27 09:43:07+09:00</td>\n      <td>2017-11-27</td>\n      <td>2017-11</td>\n    </tr>\n    <tr>\n      <th>16</th>\n      <td>50</td>\n      <td>972172</td>\n      <td>1511854245</td>\n      <td>pv</td>\n      <td>4756105</td>\n      <td>222</td>\n      <td>NaN</td>\n      <td>0.0</td>\n      <td>2017-11-28 16:30:45+09:00</td>\n      <td>2017-11-28</td>\n      <td>2017-11</td>\n    </tr>\n    <tr>\n      <th>17</th>\n      <td>50</td>\n      <td>407777</td>\n      <td>1511948105</td>\n      <td>pv</td>\n      <td>4756105</td>\n      <td>827</td>\n      <td>NaN</td>\n      <td>0.0</td>\n      <td>2017-11-29 18:35:05+09:00</td>\n      <td>2017-11-29</td>\n      <td>2017-11</td>\n    </tr>\n    <tr>\n      <th>18</th>\n      <td>50</td>\n      <td>2559047</td>\n      <td>1512108229</td>\n      <td>pv</td>\n      <td>4756105</td>\n      <td>97</td>\n      <td>NaN</td>\n      <td>0.0</td>\n      <td>2017-12-01 15:03:49+09:00</td>\n      <td>2017-12-01</td>\n      <td>2017-12</td>\n    </tr>\n    <tr>\n      <th>19</th>\n      <td>50</td>\n      <td>3408121</td>\n      <td>1512110060</td>\n      <td>pv</td>\n      <td>1320293</td>\n      <td>171</td>\n      <td>NaN</td>\n      <td>0.0</td>\n      <td>2017-12-01 15:34:20+09:00</td>\n      <td>2017-12-01</td>\n      <td>2017-12</td>\n    </tr>\n    <tr>\n      <th>20</th>\n      <td>50</td>\n      <td>4225949</td>\n      <td>1512110662</td>\n      <td>pv</td>\n      <td>1879194</td>\n      <td>999</td>\n      <td>NaN</td>\n      <td>0.0</td>\n      <td>2017-12-01 15:44:22+09:00</td>\n      <td>2017-12-01</td>\n      <td>2017-12</td>\n    </tr>\n    <tr>\n      <th>21</th>\n      <td>50</td>\n      <td>1820775</td>\n      <td>1512112710</td>\n      <td>cart</td>\n      <td>4537973</td>\n      <td>825</td>\n      <td>NaN</td>\n      <td>0.0</td>\n      <td>2017-12-01 16:18:30+09:00</td>\n      <td>2017-12-01</td>\n      <td>2017-12</td>\n    </tr>\n    <tr>\n      <th>22</th>\n      <td>50</td>\n      <td>3096190</td>\n      <td>1512179808</td>\n      <td>pv</td>\n      <td>472273</td>\n      <td>240</td>\n      <td>NaN</td>\n      <td>0.0</td>\n      <td>2017-12-02 10:56:48+09:00</td>\n      <td>2017-12-02</td>\n      <td>2017-12</td>\n    </tr>\n    <tr>\n      <th>23</th>\n      <td>50</td>\n      <td>5155205</td>\n      <td>1512179846</td>\n      <td>cart</td>\n      <td>4762182</td>\n      <td>255</td>\n      <td>NaN</td>\n      <td>0.0</td>\n      <td>2017-12-02 10:57:26+09:00</td>\n      <td>2017-12-02</td>\n      <td>2017-12</td>\n    </tr>\n    <tr>\n      <th>24</th>\n      <td>50</td>\n      <td>518956</td>\n      <td>1512181946</td>\n      <td>pv</td>\n      <td>4835206</td>\n      <td>1006</td>\n      <td>NaN</td>\n      <td>0.0</td>\n      <td>2017-12-02 11:32:26+09:00</td>\n      <td>2017-12-02</td>\n      <td>2017-12</td>\n    </tr>\n    <tr>\n      <th>25</th>\n      <td>50</td>\n      <td>120958</td>\n      <td>1512182155</td>\n      <td>buy</td>\n      <td>4762182</td>\n      <td>1008</td>\n      <td>3.0</td>\n      <td>3024.0</td>\n      <td>2017-12-02 11:35:55+09:00</td>\n      <td>2017-12-02</td>\n      <td>2017-12</td>\n    </tr>\n    <tr>\n      <th>26</th>\n      <td>50</td>\n      <td>4619331</td>\n      <td>1512302217</td>\n      <td>buy</td>\n      <td>3884119</td>\n      <td>381</td>\n      <td>7.0</td>\n      <td>2667.0</td>\n      <td>2017-12-03 20:56:57+09:00</td>\n      <td>2017-12-03</td>\n      <td>2017-12</td>\n    </tr>\n    <tr>\n      <th>27</th>\n      <td>50</td>\n      <td>5045605</td>\n      <td>1512302237</td>\n      <td>pv</td>\n      <td>820727</td>\n      <td>655</td>\n      <td>NaN</td>\n      <td>0.0</td>\n      <td>2017-12-03 20:57:17+09:00</td>\n      <td>2017-12-03</td>\n      <td>2017-12</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n### Example: What is the contribution of each item to their overall category sales?\n\nWe can also use aggregations like `sum` in conjuction with window function.\n\n::: {#b4d5b2c9 .cell execution_count=41}\n``` {.python .cell-code code-fold=\"show\"}\npd.set_option('display.max_rows', 6) \n\nquery = f\"\"\"\nselect setseed(0.112);\n\nselect\n item_id\n ,category_id\n ,item_sales / category_sales as percentage_category_sales\nfrom (\n  select\n   item_id\n   ,category_id\n   ,item_sales\n   ,sum(item_sales) over (partition by category_id) as category_sales\n  from (\n   select\n    item_id\n    ,category_id\n    ,sum(sales) as item_sales\n    from transaction_tbl_x\n    group by 1,2\n  ) a\n) b\nwhere category_sales > 0;\n\"\"\"\n\nexecute_query(query)\n```\n\n::: {.cell-output .cell-output-display execution_count=41}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>item_id</th>\n      <th>category_id</th>\n      <th>percentage_category_sales</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>644316</td>\n      <td>75275</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>4356670</td>\n      <td>75275</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>45889</td>\n      <td>75275</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>...</th>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n    </tr>\n    <tr>\n      <th>1219659</th>\n      <td>4607802</td>\n      <td>5078340</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>1219660</th>\n      <td>4052466</td>\n      <td>5078340</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>1219661</th>\n      <td>104515</td>\n      <td>5078340</td>\n      <td>0.0</td>\n    </tr>\n  </tbody>\n</table>\n<p>1219662 rows × 3 columns</p>\n</div>\n```\n:::\n:::\n\n\n## 7. Concatenation aka Union\n\nSometimes you want to concatenate multiple tables with the same set of columns (called schema) together. `union all` is simple concatenation whereas `union` will also deduplicate the rows for you, only returning rows that are not perfectly identical to one another.\n\n### Example: Concatenate monthly summary of `2017-11` and `2017-12` together.\n\nWe do not need to worry about duplicates here so we can simply use `union all`. See how we can combine `count`, `distinct` and `case when` to get monthly acitve customers and purchasers.\n\n::: {#1b5f8dfb .cell execution_count=42}\n``` {.python .cell-code code-fold=\"show\"}\nquery = f\"\"\"\nselect setseed(0.112);\n\nselect * from\n(select \n year_month\n ,count(distinct user_id) as nb_active_customer\n ,count(distinct case when behavior_type='buy' then user_id else null end) as nb_purchaser\n ,sum(sales) as total_sales\nfrom transaction_tbl_x\nwhere year_month = '2017-11'\ngroup by 1)\nunion all\n(select \n year_month\n ,count(distinct user_id) as nb_active_customer\n ,count(distinct case when behavior_type='buy' then user_id else null end) as nb_purchaser\n ,sum(sales) as total_sales\nfrom transaction_tbl_x\nwhere year_month = '2017-12'\ngroup by 1);\n\"\"\"\n\nexecute_query(query)\n```\n\n::: {.cell-output .cell-output-display execution_count=42}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>year_month</th>\n      <th>nb_active_customer</th>\n      <th>nb_purchaser</th>\n      <th>total_sales</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>2017-11</td>\n      <td>759497</td>\n      <td>58836</td>\n      <td>192782711.0</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>2017-12</td>\n      <td>679573</td>\n      <td>34938</td>\n      <td>111758189.0</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n### Example: Give me a list of unique users who made at least one purchase or viewed at least 5 unique items.\n\nConcatenate then deduplicate.\n\n::: {#cf18640c .cell execution_count=43}\n``` {.python .cell-code code-fold=\"show\"}\nquery = f\"\"\"\nselect setseed(0.112);\n\nselect \n user_id\nfrom transaction_tbl_x\nwhere behavior_type = 'buy'\ngroup by 1\nunion\nselect \n user_id\nfrom transaction_tbl_x\nwhere behavior_type = 'fav'\ngroup by 1\nhaving count(*)>=5\n\"\"\"\n\nexecute_query(query)\n```\n\n::: {.cell-output .cell-output-display execution_count=43}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>user_id</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>898251</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>576709</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>837520</td>\n    </tr>\n    <tr>\n      <th>...</th>\n      <td>...</td>\n    </tr>\n    <tr>\n      <th>92122</th>\n      <td>86617</td>\n    </tr>\n    <tr>\n      <th>92123</th>\n      <td>906571</td>\n    </tr>\n    <tr>\n      <th>92124</th>\n      <td>103138</td>\n    </tr>\n  </tbody>\n</table>\n<p>92125 rows × 1 columns</p>\n</div>\n```\n:::\n:::\n\n\nSimple concatenation will give duplicates.\n\n::: {#515486ae .cell execution_count=44}\n``` {.python .cell-code code-fold=\"show\"}\nquery = f\"\"\"\nselect setseed(0.112);\n\nselect \n user_id\nfrom transaction_tbl_x\nwhere behavior_type = 'buy'\ngroup by 1\nunion all\nselect \n user_id\nfrom transaction_tbl_x\nwhere behavior_type = 'fav'\ngroup by 1\nhaving count(*)>=5\n\"\"\"\n\nexecute_query(query)\n```\n\n::: {.cell-output .cell-output-display execution_count=44}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>user_id</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>286908</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>910422</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>669209</td>\n    </tr>\n    <tr>\n      <th>...</th>\n      <td>...</td>\n    </tr>\n    <tr>\n      <th>92359</th>\n      <td>251575</td>\n    </tr>\n    <tr>\n      <th>92360</th>\n      <td>598643</td>\n    </tr>\n    <tr>\n      <th>92361</th>\n      <td>906629</td>\n    </tr>\n  </tbody>\n</table>\n<p>92362 rows × 1 columns</p>\n</div>\n```\n:::\n:::\n\n\n## 8. Joins\n\n`join` connects data from one table to another based on columns they share. There are many types of joins but 95% of your life will revolve around `left join` and `inner join`.\n\n### Example: Among users who are active (have at least one event) on 2017-12-03, how many percent were active in 2017-11\n\n`left join` starts with all rows from the left-side table (the former one) and add rows from the right-side table (the latter one) to it, *if and only if* the rows meet the conditions given in the `on` clause. These conditions are usually for values in a column from the left-side table to be equal to, not equal to, or more/less than the ones in a column from the right-side table.\n\nBe sure to give aliases to columns you select and are joining `on`. Your query engine needs to know exactly from which table the columns came from if they have the same name.\n\n::: {#35c53f57 .cell execution_count=45}\n``` {.python .cell-code code-fold=\"show\"}\nquery = f\"\"\"\nselect setseed(0.112);\n\nwith november_active_tbl as (\nselect\n user_id\n ,1 as active_in_november\nfrom transaction_tbl_x\nwhere year_month = '2017-11'\ngroup by 1,2\n),\n\ndec3_active_tbl as (\nselect\n user_id\nfrom transaction_tbl_x\nwhere event_date = '2017-12-03'\ngroup by 1\n)\n\nselect\n dec3.user_id\n ,active_in_november\nfrom dec3_active_tbl dec3\nleft join november_active_tbl nov\non dec3.user_id = nov.user_id;\n\"\"\"\n\nexecute_query(query)\n```\n\n::: {.cell-output .cell-output-display execution_count=45}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>user_id</th>\n      <th>active_in_november</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>78674</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>755902</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>829454</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>...</th>\n      <td>...</td>\n      <td>...</td>\n    </tr>\n    <tr>\n      <th>375424</th>\n      <td>743851</td>\n      <td>&lt;NA&gt;</td>\n    </tr>\n    <tr>\n      <th>375425</th>\n      <td>543372</td>\n      <td>&lt;NA&gt;</td>\n    </tr>\n    <tr>\n      <th>375426</th>\n      <td>610566</td>\n      <td>&lt;NA&gt;</td>\n    </tr>\n  </tbody>\n</table>\n<p>375427 rows × 2 columns</p>\n</div>\n```\n:::\n:::\n\n\nAs you can see, users who were not active in 2017-11 will have null values in their `active_in_november` column. This is because we need to make sure that all rows from the left-side table (`dec3_active_tbl`) are there. Lastly, we can find the percentage by a simple aggregation. This is how you calculate percentage of returning users.\n\n::: {#cb843f5a .cell execution_count=46}\n``` {.python .cell-code code-fold=\"show\"}\nquery = f\"\"\"\nselect setseed(0.112);\n\nwith november_active_tbl as (\nselect\n user_id\n ,1 as active_in_november\nfrom transaction_tbl_x\nwhere year_month = '2017-11'\ngroup by 1,2\n),\n\ndec3_active_tbl as (\nselect\n user_id\nfrom transaction_tbl_x\nwhere event_date = '2017-12-03'\ngroup by 1\n)\n\nselect\n avg(coalesce(active_in_november,0)) as percent_active_last_month\nfrom dec3_active_tbl dec3\nleft join november_active_tbl nov\non dec3.user_id = nov.user_id;\n\"\"\"\n\nexecute_query(query)\n```\n\n::: {.cell-output .cell-output-display execution_count=46}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>percent_active_last_month</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>0.824562</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n### Example: What is the daily contribution to its total monthly sales, expressed as percentage?\n\n`inner join` is used when you only want rows where the `on` conditions are satisfied for both tables. In this case, we know that `year_month`, the key we are joining on, exists in both daily and monthly sales tables, so we can use `inner join` without fear of losing information. `inner join` has the best performance than `left join` so prioritize it if you can, especially if you are working with huge tables.\n\nOne sneaky thing you can do is that technically you can enter a condition only based on one table in the `on` clause such as `daily_sales > 0` below. It will have the same performance as when you do it on `where` clause.\n\n::: {#f6ca24bf .cell execution_count=47}\n``` {.python .cell-code code-fold=\"show\"}\npd.set_option('display.max_rows', 10) \n\nquery = f\"\"\"\nselect setseed(0.112);\n\nwith monthly_sales_tbl as (\nselect\n year_month\n ,sum(sales) as monthly_sales\nfrom transaction_tbl_x\ngroup by 1\nhaving sum(sales)>0\n),\n\ndaily_sales_tbl as (\nselect\n year_month\n ,event_date\n ,sum(sales) as daily_sales\nfrom transaction_tbl_x\ngroup by 1,2\n)\n\nselect\n daily.year_month\n ,event_date\n ,daily_sales / monthly_sales as percentage_of_monthly_sales\nfrom daily_sales_tbl daily\ninner join monthly_sales_tbl monthly\non daily.year_month = monthly.year_month\n and daily_sales > 0\norder by event_date;\n\"\"\"\n\nexecute_query(query)\n```\n\n::: {.cell-output .cell-output-display execution_count=47}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>year_month</th>\n      <th>event_date</th>\n      <th>percentage_of_monthly_sales</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>2017-11</td>\n      <td>2017-11-25</td>\n      <td>0.149288</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>2017-11</td>\n      <td>2017-11-26</td>\n      <td>0.162279</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>2017-11</td>\n      <td>2017-11-27</td>\n      <td>0.177516</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>2017-11</td>\n      <td>2017-11-28</td>\n      <td>0.165055</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>2017-11</td>\n      <td>2017-11-29</td>\n      <td>0.171182</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>2017-11</td>\n      <td>2017-11-30</td>\n      <td>0.176354</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>2017-12</td>\n      <td>2017-12-01</td>\n      <td>0.284772</td>\n    </tr>\n    <tr>\n      <th>7</th>\n      <td>2017-12</td>\n      <td>2017-12-02</td>\n      <td>0.352953</td>\n    </tr>\n    <tr>\n      <th>8</th>\n      <td>2017-12</td>\n      <td>2017-12-03</td>\n      <td>0.346453</td>\n    </tr>\n    <tr>\n      <th>9</th>\n      <td>2017-12</td>\n      <td>2017-12-04</td>\n      <td>0.016650</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n## 9. Tribal Knowledge\n\nWe have now gone through SQL techniques to accomplish most tasks as a SQL monkey. I would like to close with some tips and tricks I have learned over the years:\n\n- **Get your hands dirty.** Whether it is [the exercise](https://colab.research.google.com/github/cstorm125/cstorm125.github.io/blob/main/notebook/sql_almost_exercise.ipynb) or your own data. Get out there and make it happen!\n- **ALWAYS SPECIFY THE PARTITIONS YOU NEED IN THE `WHERE` CLAUSE**, and use the right data types.\n- **Sanity check** for data quality issues, namely duplicates, missing values, improbable values, and data types. Make sure values in columns you care about are distributed in a reasonable manner.\n- **Work with assumptions and experiments.** Have a set of clear hypotheses about what you are trying to learn/do, compose the query, run it and record the results. Work incrementally and not all at once; lest you will regret it during the debugging process. Do not just randomly write queries and hope for the best. The rabbit hole is too deep.\n- **Performance is king.** Always pick a pattern that results in better performance when possible. For instance, `inner join` over `left join`, `union all` over `union`, do not use `distinct` if values are already unique, and so on. \n- **Query code styling must be readable and consistent**. In this day and age where a coding assistant can fix your code styling in a few seconds, the best code styling for your query is the one that is most readable to your team. Whether it is tab vs space identation, leading vs trailing commas, with vs subquery vs view, capitalized vs uncapitalized keywords, just pick one style and stick with it.\n- **When in doubt `explain`**. Most query engines will show you how it plans to execute your queries. If you are a beginner, this might not be extremely helpful, but at least you can catch some simple things like if the partitions you specified are being used, is the engine making some unncessary data type conversion, which part of the process takes the moast time and so on. `explain` will only show you the plan but `explain analyze` will execute the query then tell you how it went.\n\n::: {#9d1c0b92 .cell execution_count=48}\n``` {.python .cell-code code-fold=\"show\"}\nquery = \"\"\"\nexplain analyze\nselect * from transaction_tbl\nwhere item_id = 2067266\n and category_id = 4339722\n\"\"\"\n\nprint(execute_query(query)['explain_value'][0])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n┌─────────────────────────────────────┐\n│┌───────────────────────────────────┐│\n││    Query Profiling Information    ││\n│└───────────────────────────────────┘│\n└─────────────────────────────────────┘\n explain analyze select * from transaction_tbl where item_id = 2067266  and category_id = 4339722 \n┌────────────────────────────────────────────────┐\n│┌──────────────────────────────────────────────┐│\n││              Total Time: 0.0016s             ││\n│└──────────────────────────────────────────────┘│\n└────────────────────────────────────────────────┘\n┌───────────────────────────┐\n│           QUERY           │\n└─────────────┬─────────────┘\n┌─────────────┴─────────────┐\n│      EXPLAIN_ANALYZE      │\n│    ────────────────────   │\n│           0 Rows          │\n│          (0.00s)          │\n└─────────────┬─────────────┘\n┌─────────────┴─────────────┐\n│         PROJECTION        │\n│    ────────────────────   │\n│          user_id          │\n│          item_id          │\n│         timestamp         │\n│       behavior_type       │\n│        category_id        │\n│                           │\n│           7 Rows          │\n│          (0.00s)          │\n└─────────────┬─────────────┘\n┌─────────────┴─────────────┐\n│         TABLE_SCAN        │\n│    ────────────────────   │\n│           Table:          │\n│      transaction_tbl      │\n│                           │\n│   Type: Sequential Scan   │\n│                           │\n│        Projections:       │\n│          item_id          │\n│        category_id        │\n│          user_id          │\n│         timestamp         │\n│       behavior_type       │\n│                           │\n│          Filters:         │\n│      item_id=2067266      │\n│    category_id=4339722    │\n│                           │\n│           7 Rows          │\n│          (0.00s)          │\n└───────────────────────────┘\n\n```\n:::\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}